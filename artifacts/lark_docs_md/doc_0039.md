https://lark-parser.readthedocs.io/en/stable/visitors.html

- [Home](https://lark-parser.readthedocs.io/en/stable/index.html)
- Transformers & Visitors
- [Edit on GitHub](https://github.com/lark-parser/lark/blob/acfe33d943a1310f3ca26145eb2896bc5c4955c9/docs/visitors.rst)

[Previous](https://lark-parser.readthedocs.io/en/stable/classes.html "API Reference") [Next](https://lark-parser.readthedocs.io/en/stable/forest.html "Working with the SPPF")

* * *

# Transformers & Visitors [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#transformers-visitors "Permalink to this heading")

Transformers & Visitors provide a convenient interface to process the
parse-trees that Lark returns.

They are used by inheriting from the correct class (visitor or transformer),
and implementing methods corresponding to the rule you wish to process. Each
method accepts the children as an argument. That can be modified using the
`v_args` decorator, which allows one to inline the arguments (akin to `*args`),
or add the tree `meta` property as an argument.

See: [visitors.py](https://github.com/lark-parser/lark/blob/master/lark/visitors.py)

## Visitor [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#visitor "Permalink to this heading")

Visitors visit each node of the tree, and run the appropriate method on it according to the node’s data.

They work bottom-up, starting with the leaves and ending at the root of the tree.

There are two classes that implement the visitor interface:

- `Visitor`: Visit every node (without recursion)

- `Visitor_Recursive`: Visit every node using recursion. Slightly faster.


Example:

```
class IncreaseAllNumbers(Visitor):
    def number(self, tree):
        assert tree.data == "number"
        tree.children[0] += 1

IncreaseAllNumbers().visit(parse_tree)

```

_class_ lark.visitors.Visitor( _\*args_, _\*\*kwds_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor "Permalink to this definition")

Tree visitor, non-recursive (can handle huge trees).

Visiting a node calls its methods (provided by the user via inheritance) according to `tree.data`

visit( _tree:[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]_)→[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\] [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor.visit "Permalink to this definition")

Visits the tree, starting with the leaves and finally the root (bottom-up)

visit\_topdown( _tree:[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]_)→[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\] [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor.visit_topdown "Permalink to this definition")

Visit the tree, starting at the root, and ending at the leaves (top-down)

\_\_default\_\_( _tree_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor.__default__ "Permalink to this definition")

Default function that is called if there is no attribute matching `tree.data`

Can be overridden. Defaults to doing nothing.

_class_ lark.visitors.Visitor\_Recursive( _\*args_, _\*\*kwds_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor_Recursive "Permalink to this definition")

Bottom-up visitor, recursive.

Visiting a node calls its methods (provided by the user via inheritance) according to `tree.data`

Slightly faster than the non-recursive version.

visit( _tree:[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]_)→[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\] [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor_Recursive.visit "Permalink to this definition")

Visits the tree, starting with the leaves and finally the root (bottom-up)

visit\_topdown( _tree:[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]_)→[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\] [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor_Recursive.visit_topdown "Permalink to this definition")

Visit the tree, starting at the root, and ending at the leaves (top-down)

\_\_default\_\_( _tree_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Visitor_Recursive.__default__ "Permalink to this definition")

Default function that is called if there is no attribute matching `tree.data`

Can be overridden. Defaults to doing nothing.

## Interpreter [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#interpreter "Permalink to this heading")

_class_ lark.visitors.Interpreter( _\*args_, _\*\*kwds_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Interpreter "Permalink to this definition")

Interpreter walks the tree starting at the root.

Visits the tree, starting with the root and finally the leaves (top-down)

For each tree node, it calls its methods (provided by user via inheritance) according to `tree.data`.

Unlike `Transformer` and `Visitor`, the Interpreter doesn’t automatically visit its sub-branches.
The user has to explicitly call `visit`, `visit_children`, or use the `@visit_children_decor`.
This allows the user to implement branching and loops.

Example:

```
class IncreaseSomeOfTheNumbers(Interpreter):
    def number(self, tree):
        tree.children[0] += 1

    def skip(self, tree):
        # skip this subtree. don't change any number node inside it.
        pass

    IncreaseSomeOfTheNumbers().visit(parse_tree)

```

## Transformer [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#transformer "Permalink to this heading")

_class_ lark.visitors.Transformer( _visit\_tokens:bool=True_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer "Permalink to this definition")

Transformers work bottom-up (or depth-first), starting with visiting the leaves and working
their way up until ending at the root of the tree.

For each node visited, the transformer will call the appropriate method (callbacks), according to the
node’s `data`, and use the returned value to replace the node, thereby creating a new tree structure.

Transformers can be used to implement map & reduce patterns. Because nodes are reduced from leaf to root,
at any point the callbacks may assume the children have already been transformed (if applicable).

If the transformer cannot find a method with the right name, it will instead call `__default__`, which by
default creates a copy of the node.

To discard a node, return Discard ( `lark.visitors.Discard`).

`Transformer` can do anything `Visitor` can do, but because it reconstructs the tree,
it is slightly less efficient.

A transformer without methods essentially performs a non-memoized partial deepcopy.

All these classes implement the transformer interface:

- `Transformer` \- Recursively transforms the tree. This is the one you probably want.

- `Transformer_InPlace` \- Non-recursive. Changes the tree in-place instead of returning new instances

- `Transformer_InPlaceRecursive` \- Recursive. Changes the tree in-place instead of returning new instances


Parameters:

**visit\_tokens** ( _bool_ _,_ _optional_) – Should the transformer visit tokens in addition to rules.
Setting this to `False` is slightly faster. Defaults to `True`.
(For processing ignored tokens, use the `lexer_callbacks` options)

transform( _tree:[Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]_)→\_Return\_T [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer.transform "Permalink to this definition")

Transform the given tree, and return the final result

\_\_mul\_\_( _other:Union\[ [Transformer](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer "lark.visitors.Transformer"),TransformerChain\[\_Leaf\_U,\_Return\_V\]\]_)→TransformerChain\[\_Leaf\_T,\_Return\_V\] [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer.__mul__ "Permalink to this definition")

Chain two transformers together, returning a new transformer.

\_\_default\_\_( _data_, _children_, _meta_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer.__default__ "Permalink to this definition")

Default function that is called if there is no attribute matching `data`

Can be overridden. Defaults to creating a new copy of the tree node (i.e. `return Tree(data, children, meta)`)

\_\_default\_token\_\_( _token_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer.__default_token__ "Permalink to this definition")

Default function that is called if there is no attribute matching `token.type`

Can be overridden. Defaults to returning the token as-is.

Example:

```
from lark import Tree, Transformer

class EvalExpressions(Transformer):
    def expr(self, args):
            return eval(args[0])

t = Tree('a', [Tree('expr', ['1+2'])])
print(EvalExpressions().transform( t ))

# Prints: Tree(a, [3])

```

Example:

```
class T(Transformer):
    INT = int
    NUMBER = float
    def NAME(self, name):
        return lookup_dict.get(name, name)

T(visit_tokens=True).transform(tree)

```

_class_ lark.visitors.Transformer\_NonRecursive( _visit\_tokens:bool=True_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer_NonRecursive "Permalink to this definition")

Same as Transformer but non-recursive.

Like Transformer, it doesn’t change the original tree.

Useful for huge trees.

_class_ lark.visitors.Transformer\_InPlace( _visit\_tokens:bool=True_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer_InPlace "Permalink to this definition")

Same as Transformer, but non-recursive, and changes the tree in-place instead of returning new instances

Useful for huge trees. Conservative in memory.

_class_ lark.visitors.Transformer\_InPlaceRecursive( _visit\_tokens:bool=True_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer_InPlaceRecursive "Permalink to this definition")

Same as Transformer, recursive, but changes the tree in-place instead of returning new instances

## v\_args [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#v-args "Permalink to this heading")

lark.visitors.v\_args( _inline:bool=False_, _meta:bool=False_, _tree:bool=False_, _wrapper:Optional\[Callable\]=None_)→Callable\[\[Union\[Callable\[\[...\],\_Return\_T\],type\]\],Union\[Callable\[\[...\],\_Return\_T\],type\]\] [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.v_args "Permalink to this definition")

A convenience decorator factory for modifying the behavior of user-supplied visitor methods.

By default, callback methods of transformers/visitors accept one argument - a list of the node’s children.

`v_args` can modify this behavior. When used on a transformer/visitor class definition,
it applies to all the callback methods inside it.

`v_args` can be applied to a single method, or to an entire class. When applied to both,
the options given to the method take precedence.

Parameters:

- **inline** ( _bool_ _,_ _optional_) – Children are provided as `*args` instead of a list argument (not recommended for very long lists).

- **meta** ( _bool_ _,_ _optional_) – Provides two arguments: `meta` and `children` (instead of just the latter)

- **tree** ( _bool_ _,_ _optional_) – Provides the entire tree as the argument, instead of the children.

- **wrapper** ( _function_ _,_ _optional_) – Provide a function to decorate all methods.


Example

```
@v_args(inline=True)
class SolveArith(Transformer):
    def add(self, left, right):
        return left + right

    @v_args(meta=True)
    def mul(self, meta, children):
        logger.info(f'mul at line {meta.line}')
        left, right = children
        return left * right

class ReverseNotation(Transformer_InPlace):
    @v_args(tree=True)
    def tree_node(self, tree):
        tree.children = tree.children[::-1]

```

## merge\_transformers [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#merge-transformers "Permalink to this heading")

lark.visitors.merge\_transformers( _base\_transformer=None_, _\*\*transformers\_to\_merge_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.merge_transformers "Permalink to this definition")

Merge a collection of transformers into the base\_transformer, each into its own ‘namespace’.

When called, it will collect the methods from each transformer, and assign them to base\_transformer,
with their name prefixed with the given keyword, as `prefix__methodname`.

This function is especially useful for processing grammars that import other grammars,
thereby creating some of their rules in a ‘namespace’. (i.e with a consistent name prefix).
In this case, the key for the transformer should match the name of the imported grammar.

Parameters:

- **base\_transformer** ( [_Transformer_](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer "lark.visitors.Transformer") _,_ _optional_) – The transformer that all other transformers will be added to.

- **\*\*transformers\_to\_merge** – Keyword arguments, in the form of `name_prefix = transformer`.


Raises:

**AttributeError** – In case of a name collision in the merged methods

Example

```
class TBase(Transformer):
    def start(self, children):
        return children[0] + 'bar'

class TImportedGrammar(Transformer):
    def foo(self, children):
        return "foo"

composed_transformer = merge_transformers(TBase(), imported=TImportedGrammar())

t = Tree('start', [ Tree('imported__foo', []) ])

assert composed_transformer.transform(t) == 'foobar'

```

## Discard [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#discard "Permalink to this heading")

`Discard` is the singleton instance of `_DiscardType`.

_class_ lark.visitors.\_DiscardType [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors._DiscardType "Permalink to this definition")

When the Discard value is returned from a transformer callback,
that node is discarded and won’t appear in the parent.

Note

This feature is disabled when the transformer is provided to Lark
using the `transformer` keyword (aka Tree-less LALR mode).

Example

```
class T(Transformer):
    def ignore_tree(self, children):
        return Discard

    def IGNORE_TOKEN(self, token):
        return Discard

```

## VisitError [](https://lark-parser.readthedocs.io/en/stable/visitors.html\#visiterror "Permalink to this heading")

_class_ lark.exceptions.VisitError( _rule_, _obj_, _orig\_exc_) [](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.exceptions.VisitError "Permalink to this definition")

VisitError is raised when visitors are interrupted by an exception

It provides the following attributes for inspection:

Parameters:

- **rule** – the name of the visit rule that failed

- **obj** – the tree-node or token that was being processed

- **orig\_exc** – the exception that cause it to fail


Note: These parameters are available as attributes

Versions[latest](https://lark-parser.readthedocs.io/en/latest/visitors.html)**[stable](https://lark-parser.readthedocs.io/en/stable/visitors.html)**Downloads[PDF](https://lark-parser.readthedocs.io/_/downloads/en/stable/pdf/)[HTML](https://lark-parser.readthedocs.io/_/downloads/en/stable/htmlzip/)[EPUB](https://lark-parser.readthedocs.io/_/downloads/en/stable/epub/)On Read the Docs[Project Home](https://app.readthedocs.org/projects/lark-parser/?utm_source=lark-parser&utm_content=flyout)[Builds](https://app.readthedocs.org/projects/lark-parser/builds/?utm_source=lark-parser&utm_content=flyout)Search

* * *

[Addons documentation](https://docs.readthedocs.io/page/addons.html?utm_source=lark-parser&utm_content=flyout) ― Hosted by
[Read the Docs](https://about.readthedocs.com/?utm_source=lark-parser&utm_content=flyout)