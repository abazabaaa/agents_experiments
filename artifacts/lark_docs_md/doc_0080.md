https://lark-parser.readthedocs.io/en/stable/classes.html

- [Home](https://lark-parser.readthedocs.io/en/stable/index.html)
- API Reference
- [Edit on GitHub](https://github.com/lark-parser/lark/blob/acfe33d943a1310f3ca26145eb2896bc5c4955c9/docs/classes.rst)

[Previous](https://lark-parser.readthedocs.io/en/stable/tree_construction.html "Tree Construction Reference") [Next](https://lark-parser.readthedocs.io/en/stable/visitors.html "Transformers & Visitors")

* * *

# API Reference [](https://lark-parser.readthedocs.io/en/stable/classes.html\#api-reference "Permalink to this heading")

## Lark [](https://lark-parser.readthedocs.io/en/stable/classes.html\#lark "Permalink to this heading")

_class_ lark.Lark( _grammar:Union\[Grammar,str,IO\[str\]\]_, _\*\*options_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark "Permalink to this definition")

Main interface for the library.

It’s mostly a thin wrapper for the many different parsers, and for the tree constructor.

Parameters:

- **grammar** – a string or file-object containing the grammar spec (using Lark’s ebnf syntax)

- **options** – a dictionary controlling various aspects of Lark.


Example

```
>>> Lark(r'''start: "foo" ''')
Lark(...)

```

**=== General Options ===**

start

The start symbol. Either a string, or a list of strings for multiple possible starts (Default: “start”)

debug

Display debug information and extra warnings. Use only when debugging (Default: `False`)
When used with Earley, it generates a forest graph as “sppf.png”, if ‘dot’ is installed.

strict

Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.

transformer

Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)

propagate\_positions

Propagates positional attributes into the ‘meta’ attribute of all tree branches.
Sets attributes: (line, column, end\_line, end\_column, start\_pos, end\_pos,

> container\_line, container\_column, container\_end\_line, container\_end\_column)

Accepts `False`, `True`, or a callable, which will filter which nodes to ignore when propagating.

maybe\_placeholders

When `True`, the `[]` operator returns `None` when not matched.
When `False`, `[]` behaves like the `?` operator, and returns no value at all.
(default= `True`)

cache

Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

- When `False`, does nothing (default)

- When `True`, caches to a temporary file in the local directory

- When given a string, caches to the path pointed by the string


regex

When True, uses the `regex` module instead of the stdlib `re`.

g\_regex\_flags

Flags that are applied to all terminals (both regex and strings)

keep\_all\_tokens

Prevent the tree builder from automagically removing “punctuation” tokens (Default: `False`)

tree\_class

Lark will produce trees comprised of instances of this class instead of the default `lark.Tree`.

**=== Algorithm Options ===**

parser

Decides which parser engine to use. Accepts “earley” or “lalr”. (Default: “earley”).
(there is also a “cyk” option for legacy)

lexer

Decides whether or not to use a lexer stage

- “auto” (default): Choose for me based on the parser

- “basic”: Use a basic lexer

- “contextual”: Stronger lexer (only works with parser=”lalr”)

- “dynamic”: Flexible and powerful (only with parser=”earley”)

- “dynamic\_complete”: Same as dynamic, but tries _every_ variation of tokenizing possible.


ambiguity

Decides how to handle ambiguity in the parse. Only relevant if parser=”earley”

- “resolve”: The parser will automatically choose the simplest derivation
(it chooses consistently: greedy for tokens, non-greedy for rules)

- “explicit”: The parser will return all derivations wrapped in “\_ambig” tree nodes (i.e. a forest).

- “forest”: The parser will return the root of the shared packed parse forest.


**=== Misc. / Domain Specific Options ===**

postlex

Lexer post-processing (Default: `None`) Only works with the basic and contextual lexers.

priority

How priorities should be evaluated - “auto”, `None`, “normal”, “invert” (Default: “auto”)

lexer\_callbacks

Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.

use\_bytes

Accept an input of type `bytes` instead of `str`.

ordered\_sets

Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)

edit\_terminals

A callback for editing the terminals before parse.

import\_paths

A List of either paths or loader functions to specify from where grammars are imported

source\_path

Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading

**=== End of Options ===**

save( _f_, _exclude\_options:Collection\[str\]=()_)→None [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.save "Permalink to this definition")

Saves the instance into the given file object

Useful for caching and multiprocessing.

_classmethod_ load( _f_)→\_T [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.load "Permalink to this definition")

Loads an instance from the given file object

Useful for caching and multiprocessing.

_classmethod_ open( _grammar\_filename:str_, _rel\_to:Optional\[str\]=None_, _\*\*options_)→\_T [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.open "Permalink to this definition")

Create an instance of Lark with the grammar given by its filename

If `rel_to` is provided, the function will find the grammar filename in relation to it.

Example

```
>>> Lark.open("grammar_file.lark", rel_to=__file__, parser="lalr")
Lark(...)

```

_classmethod_ open\_from\_package( _package:str_, _grammar\_path:str_, _search\_paths:Sequence\[str\]=\[''\]_, _\*\*options_)→\_T [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.open_from_package "Permalink to this definition")

Create an instance of Lark with the grammar loaded from within the package package.
This allows grammar loading from zipapps.

Imports in the grammar will use the package and search\_paths provided, through FromPackageLoader

Example

Lark.open\_from\_package(\_\_name\_\_, “example.lark”, (“grammars”,), parser=…)

lex( _text:str_, _dont\_ignore:bool=False_)→Iterator\[ [Token](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token "lark.lexer.Token")\] [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.lex "Permalink to this definition")

Only lex (and postlex) the text, without parsing it. Only relevant when lexer=’basic’

When dont\_ignore=True, the lexer will return all tokens, even those marked for %ignore.

Raises:

[**UnexpectedCharacters**](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedCharacters "lark.exceptions.UnexpectedCharacters") – In case the lexer cannot find a suitable match.

get\_terminal( _name:str_)→TerminalDef [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.get_terminal "Permalink to this definition")

Get information about a terminal

parse\_interactive( _text:Optional\[str\]=None_, _start:Optional\[str\]=None_)→[InteractiveParser](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser "lark.parsers.lalr_interactive_parser.InteractiveParser") [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.parse_interactive "Permalink to this definition")

Start an interactive parsing session.

Parameters:

- **text** ( _str_ _,_ _optional_) – Text to be parsed. Required for `resume_parse()`.

- **start** ( _str_ _,_ _optional_) – Start symbol


Returns:

A new InteractiveParser instance.

See Also: `Lark.parse()`

parse( _text:str_, _start:Optional\[str\]=None_, _on\_error:Optional\[Callable\[\[ [UnexpectedInput](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedInput "lark.exceptions.UnexpectedInput")\],bool\]\]=None_)→ParseTree [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Lark.parse "Permalink to this definition")

Parse the given text, according to the options provided.

Parameters:

- **text** ( _str_) – Text to be parsed.

- **start** ( _str_ _,_ _optional_) – Required if Lark was given multiple possible start symbols (using the start option).

- **on\_error** ( _function_ _,_ _optional_) – if provided, will be called on UnexpectedToken error. Return true to resume parsing.
LALR only. See examples/advanced/error\_handling.py for an example of how to use on\_error.


Returns:

If a transformer is supplied to `__init__`, returns whatever is the
result of the transformation. Otherwise, returns a Tree instance.

Raises:

[**UnexpectedInput**](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedInput "lark.exceptions.UnexpectedInput") – On a parse error, one of these sub-exceptions will rise:
`UnexpectedCharacters`, `UnexpectedToken`, or `UnexpectedEOF`.
For convenience, these sub-exceptions also inherit from `ParserError` and `LexerError`.

### Using Unicode character classes with `regex` [](https://lark-parser.readthedocs.io/en/stable/classes.html\#using-unicode-character-classes-with-regex "Permalink to this heading")

Python’s builtin `re` module has a few persistent known bugs and also won’t parse
advanced regex features such as character classes.
With `pip install lark[regex]`, the `regex` module will be
installed alongside lark and can act as a drop-in replacement to `re`.

Any instance of Lark instantiated with `regex=True` will use the `regex` module instead of `re`.

For example, we can use character classes to match PEP-3131 compliant Python identifiers:

```
from lark import Lark
>>> g = Lark(r"""
                    ?start: NAME
                    NAME: ID_START ID_CONTINUE*
                    ID_START: /[\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}_]+/
                    ID_CONTINUE: ID_START | /[\p{Mn}\p{Mc}\p{Nd}\p{Pc}·]+/
                """, regex=True)

>>> g.parse('வணக்கம்')
'வணக்கம்'

```

## Tree [](https://lark-parser.readthedocs.io/en/stable/classes.html\#tree "Permalink to this heading")

_class_ lark.Tree( _data:str_, _children:List\[Union\[\_Leaf\_T, [Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.Tree")\[\_Leaf\_T\]\]\]_, _meta:Optional\[Meta\]=None_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "Permalink to this definition")

The main tree class.

Creates a new tree, and stores “data” and “children” in attributes of the same name.
Trees can be hashed and compared.

Parameters:

- **data** – The name of the rule or alias

- **children** – List of matched sub-rules and terminals

- **meta** –

Line & Column numbers (if `propagate_positions` is enabled).
meta attributes: (line, column, end\_line, end\_column, start\_pos, end\_pos,


> container\_line, container\_column, container\_end\_line, container\_end\_column)


container\_\* attributes consider all symbols, including those that have been inlined in the tree.
For example, in the rule ‘a: \_A B \_C’, the regular attributes will mark the start and end of B,
but the container\_\* attributes will also include \_A and \_C in the range. However, rules that
contain ‘a’ will consider it in full, including \_A and \_C for all attributes.


pretty( _indent\_str:str=''_)→str [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree.pretty "Permalink to this definition")

Returns an indented string representation of the tree.

Great for debugging.

\_\_rich\_\_( _parent:Optional\[rich.tree.Tree\]=None_)→rich.tree.Tree [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree.__rich__ "Permalink to this definition")

Returns a tree widget for the ‘rich’ library.

Example

::

from rich import print
from lark import Tree

tree = Tree(‘root’, \[‘node1’, ‘node2’\])
print(tree)

iter\_subtrees()→Iterator\[ [Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]\] [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree.iter_subtrees "Permalink to this definition")

Depth-first iteration.

Iterates over all the subtrees, never returning to the same node twice (Lark’s parse-tree is actually a DAG).

iter\_subtrees\_topdown() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree.iter_subtrees_topdown "Permalink to this definition")

Breadth-first iteration.

Iterates over all the subtrees, return nodes in order like pretty() does.

find\_pred( _pred:Callable\[\[ [Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]\],bool\]_)→Iterator\[ [Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]\] [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree.find_pred "Permalink to this definition")

Returns all nodes of the tree that evaluate pred(node) as true.

find\_data( _data:str_)→Iterator\[ [Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.tree.Tree")\[\_Leaf\_T\]\] [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree.find_data "Permalink to this definition")

Returns all nodes of the tree whose data equals the given data.

scan\_values( _pred:Callable\[\[Union\[\_Leaf\_T, [Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.Tree")\[\_Leaf\_T\]\]\],bool\]_)→Iterator\[\_Leaf\_T\] [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree.scan_values "Permalink to this definition")

Return all values in the tree that evaluate pred(value) as true.

This can be used to find all the tokens in the tree.

Example

```
>>> all_tokens = tree.scan_values(lambda v: isinstance(v, Token))

```

## Token [](https://lark-parser.readthedocs.io/en/stable/classes.html\#token "Permalink to this heading")

_class_ lark.Token( _type:str_, _value:Any_, _start\_pos:Optional\[int\]=None_, _line:Optional\[int\]=None_, _column:Optional\[int\]=None_, _end\_line:Optional\[int\]=None_, _end\_column:Optional\[int\]=None_, _end\_pos:Optional\[int\]=None_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token "Permalink to this definition")_class_ lark.Token( _type\_:str_, _value:Any_, _start\_pos:Optional\[int\]=None_, _line:Optional\[int\]=None_, _column:Optional\[int\]=None_, _end\_line:Optional\[int\]=None_, _end\_column:Optional\[int\]=None_, _end\_pos:Optional\[int\]=None_)

A string with meta-information, that is produced by the lexer.

When parsing text, the resulting chunks of the input that haven’t been discarded,
will end up in the tree as Token instances. The Token class inherits from Python’s `str`,
so normal string comparisons and operations will work as expected.

type [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.type "Permalink to this definition")

Name of the token (as specified in grammar)

Type:

str

value [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.value "Permalink to this definition")

Value of the token (redundant, as `token.value == token` will always be true)

Type:

Any

start\_pos [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.start_pos "Permalink to this definition")

The index of the token in the text

Type:

Optional\[int\]

line [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.line "Permalink to this definition")

The line of the token in the text (starting with 1)

Type:

Optional\[int\]

column [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.column "Permalink to this definition")

The column of the token in the text (starting with 1)

Type:

Optional\[int\]

end\_line [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.end_line "Permalink to this definition")

The line where the token ends

Type:

Optional\[int\]

end\_column [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.end_column "Permalink to this definition")

The next column after the end of the token. For example,
if the token is a single character with a column value of 4,
end\_column will be 5.

Type:

Optional\[int\]

end\_pos [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token.end_pos "Permalink to this definition")

the index where the token ends (basically `start_pos + len(token)`)

Type:

Optional\[int\]

## Transformer, Visitor & Interpreter [](https://lark-parser.readthedocs.io/en/stable/classes.html\#transformer-visitor-interpreter "Permalink to this heading")

See [Transformers & Visitors](https://lark-parser.readthedocs.io/en/stable/visitors.html).

## ForestVisitor, ForestTransformer, & TreeForestTransformer [](https://lark-parser.readthedocs.io/en/stable/classes.html\#forestvisitor-foresttransformer-treeforesttransformer "Permalink to this heading")

See [Working with the SPPF](https://lark-parser.readthedocs.io/en/stable/forest.html).

## UnexpectedInput [](https://lark-parser.readthedocs.io/en/stable/classes.html\#unexpectedinput "Permalink to this heading")

_class_ lark.exceptions.UnexpectedInput [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedInput "Permalink to this definition")

UnexpectedInput Error.

Used as a base class for the following exceptions:

- `UnexpectedCharacters`: The lexer encountered an unexpected string

- `UnexpectedToken`: The parser received an unexpected token

- `UnexpectedEOF`: The parser expected a token, but the input ended


After catching one of these exceptions, you may call the following helper methods to create a nicer error message.

get\_context( _text:str_, _span:int=40_)→str [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedInput.get_context "Permalink to this definition")

Returns a pretty string pinpointing the error in the text,
with span amount of context characters around it.

Note

The parser doesn’t hold a copy of the text it has to parse,
so you have to provide it again

match\_examples( _parse\_fn:Callable\[\[str\], [Tree](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Tree "lark.Tree")\]_, _examples:Union\[Mapping\[T,Iterable\[str\]\],Iterable\[Tuple\[T,Iterable\[str\]\]\]\]_, _token\_type\_match\_fallback:bool=False_, _use\_accepts:bool=True_)→Optional\[T\] [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedInput.match_examples "Permalink to this definition")

Allows you to detect what’s wrong in the input text by matching
against example errors.

Given a parser instance and a dictionary mapping some label with
some malformed syntax examples, it’ll return the label for the
example that bests matches the current error. The function will
iterate the dictionary until it finds a matching error, and
return the corresponding value.

For an example usage, see examples/error\_reporting\_lalr.py

Parameters:

- **parse\_fn** – parse function (usually `lark_instance.parse`)

- **examples** – dictionary of `{'example_string': value}`.

- **use\_accepts** – Recommended to keep this as `use_accepts=True`.


_class_ lark.exceptions.UnexpectedToken( _token_, _expected_, _considered\_rules=None_, _state=None_, _interactive\_parser=None_, _terminals\_by\_name=None_, _token\_history=None_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedToken "Permalink to this definition")

An exception that is raised by the parser, when the token it received
doesn’t match any valid step forward.

Parameters:

- **token** – The mismatched token

- **expected** – The set of expected tokens

- **considered\_rules** – Which rules were considered, to deduce the expected tokens

- **state** – A value representing the parser state. Do not rely on its value or type.

- **interactive\_parser** – An instance of `InteractiveParser`, that is initialized to the point of failure,
and can be used for debugging and error handling.


Note: These parameters are available as attributes of the instance.

_class_ lark.exceptions.UnexpectedCharacters( _seq_, _lex\_pos_, _line_, _column_, _allowed=None_, _considered\_tokens=None_, _state=None_, _token\_history=None_, _terminals\_by\_name=None_, _considered\_rules=None_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedCharacters "Permalink to this definition")

An exception that is raised by the lexer, when it cannot match the next
string of characters to any of its terminals.

_class_ lark.exceptions.UnexpectedEOF( _expected_, _state=None_, _terminals\_by\_name=None_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.exceptions.UnexpectedEOF "Permalink to this definition")

An exception that is raised by the parser, when the input ends while it still expects a token.

## InteractiveParser [](https://lark-parser.readthedocs.io/en/stable/classes.html\#interactiveparser "Permalink to this heading")

_class_ lark.parsers.lalr\_interactive\_parser.InteractiveParser( _parser_, _parser\_state:ParserState_, _lexer\_thread:LexerThread_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser "Permalink to this definition")

InteractiveParser gives you advanced control over parsing and error handling when parsing with LALR.

For a simpler interface, see the `on_error` argument to `Lark.parse()`.

feed\_token( _token:[Token](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token "lark.lexer.Token")_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser.feed_token "Permalink to this definition")

Feed the parser with a token, and advance it to the next state, as if it received it from the lexer.

Note that `token` has to be an instance of `Token`.

exhaust\_lexer()→List\[ [Token](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.Token "lark.lexer.Token")\] [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser.exhaust_lexer "Permalink to this definition")

Try to feed the rest of the lexer state into the interactive parser.

Note that this modifies the instance in place and does not feed an ‘$END’ Token

as\_immutable() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser.as_immutable "Permalink to this definition")

Convert to an `ImmutableInteractiveParser`.

pretty() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser.pretty "Permalink to this definition")

Print the output of `choices()` in a way that’s easier to read.

choices() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser.choices "Permalink to this definition")

Returns a dictionary of token types, matched to their action in the parser.

Only returns token types that are accepted by the current state.

Updated by `feed_token()`.

accepts() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser.accepts "Permalink to this definition")

Returns the set of possible tokens that will advance the parser into a new valid state.

resume\_parse() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.InteractiveParser.resume_parse "Permalink to this definition")

Resume automated parsing from the current state.

_class_ lark.parsers.lalr\_interactive\_parser.ImmutableInteractiveParser( _parser_, _parser\_state:ParserState_, _lexer\_thread:LexerThread_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser "Permalink to this definition")

Same as `InteractiveParser`, but operations create a new instance instead
of changing it in-place.

feed\_token( _token_) [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser.feed_token "Permalink to this definition")

Feed the parser with a token, and advance it to the next state, as if it received it from the lexer.

Note that `token` has to be an instance of `Token`.

exhaust\_lexer() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser.exhaust_lexer "Permalink to this definition")

Try to feed the rest of the lexer state into the parser.

Note that this returns a new ImmutableInteractiveParser and does not feed an ‘$END’ Token

as\_mutable() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser.as_mutable "Permalink to this definition")

Convert to an `InteractiveParser`.

choices() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser.choices "Permalink to this definition")

Returns a dictionary of token types, matched to their action in the parser.

Only returns token types that are accepted by the current state.

Updated by `feed_token()`.

pretty() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser.pretty "Permalink to this definition")

Print the output of `choices()` in a way that’s easier to read.

resume\_parse() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser.resume_parse "Permalink to this definition")

Resume automated parsing from the current state.

accepts() [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.parsers.lalr_interactive_parser.ImmutableInteractiveParser.accepts "Permalink to this definition")

Returns the set of possible tokens that will advance the parser into a new valid state.

## ast\_utils [](https://lark-parser.readthedocs.io/en/stable/classes.html\#ast-utils "Permalink to this heading")

For an example of using `ast_utils`, see [/examples/advanced/create\_ast.py](https://lark-parser.readthedocs.io/en/stable/examples/advanced/create_ast.html)

_class_ lark.ast\_utils.Ast [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.ast_utils.Ast "Permalink to this definition")

Abstract class

Subclasses will be collected by create\_transformer()

_class_ lark.ast\_utils.AsList [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.ast_utils.AsList "Permalink to this definition")

Abstract class

Subclasses will be instantiated with the parse results as a single list, instead of as arguments.

lark.ast\_utils.create\_transformer( _ast\_module:module_, _transformer:~typing.Optional\[~lark.visitors.Transformer\]=None_, _decorator\_factory:~typing.Callable=<functionv\_args>_)→[Transformer](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer "lark.visitors.Transformer") [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.ast_utils.create_transformer "Permalink to this definition")

Collects Ast subclasses from the given module, and creates a Lark transformer that builds the AST.

For each class, we create a corresponding rule in the transformer, with a matching name.
CamelCase names will be converted into snake\_case. Example: “CodeBlock” -> “code\_block”.

Classes starting with an underscore (\_) will be skipped.

Parameters:

- **ast\_module** – A Python module containing all the subclasses of `ast_utils.Ast`

- **transformer** ( _Optional_ _\[_ [_Transformer_](https://lark-parser.readthedocs.io/en/stable/visitors.html#lark.visitors.Transformer "lark.visitors.Transformer") _\]_) – An initial transformer. Its attributes may be overwritten.

- **decorator\_factory** ( _Callable_) – An optional callable accepting two booleans, inline, and meta,
and returning a decorator for the methods of `transformer`. (default: `v_args`).


## Indenter [](https://lark-parser.readthedocs.io/en/stable/classes.html\#indenter "Permalink to this heading")

_class_ lark.indenter.Indenter [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.indenter.Indenter "Permalink to this definition")

This is a postlexer that “injects” indent/dedent tokens based on indentation.

It keeps track of the current indentation, as well as the current level of parentheses.
Inside parentheses, the indentation is ignored, and no indent/dedent tokens get generated.

Note: This is an abstract class. To use it, inherit and implement all its abstract methods:

- tab\_len

- NL\_type

- OPEN\_PAREN\_types, CLOSE\_PAREN\_types

- INDENT\_type, DEDENT\_type


See also: the `postlex` option in Lark.

_class_ lark.indenter.PythonIndenter [](https://lark-parser.readthedocs.io/en/stable/classes.html#lark.indenter.PythonIndenter "Permalink to this definition")

A postlexer that “injects” \_INDENT/\_DEDENT tokens based on indentation, according to the Python syntax.

See also: the `postlex` option in Lark.

Versions[latest](https://lark-parser.readthedocs.io/en/latest/classes.html)**[stable](https://lark-parser.readthedocs.io/en/stable/classes.html)**Downloads[PDF](https://lark-parser.readthedocs.io/_/downloads/en/stable/pdf/)[HTML](https://lark-parser.readthedocs.io/_/downloads/en/stable/htmlzip/)[EPUB](https://lark-parser.readthedocs.io/_/downloads/en/stable/epub/)On Read the Docs[Project Home](https://app.readthedocs.org/projects/lark-parser/?utm_source=lark-parser&utm_content=flyout)[Builds](https://app.readthedocs.org/projects/lark-parser/builds/?utm_source=lark-parser&utm_content=flyout)Search

* * *

[Addons documentation](https://docs.readthedocs.io/page/addons.html?utm_source=lark-parser&utm_content=flyout) ― Hosted by
[Read the Docs](https://about.readthedocs.com/?utm_source=lark-parser&utm_content=flyout)