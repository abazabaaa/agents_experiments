https://lark-parser.readthedocs.io/en/stable/_downloads/fc674523e7ef0712dfc331b1ddd10972/dynamic_complete.ipynb

```
{
  "cells": [\
    {\
      "cell_type": "markdown",\
      "metadata": {},\
      "source": [\
        "\n# Using lexer dynamic_complete\n\nDemonstrates how to use ``lexer='dynamic_complete'`` and ``ambiguity='explicit'``\n\nSometimes you have data that is highly ambiguous or 'broken' in some sense.\nWhen using ``parser='earley'`` and ``lexer='dynamic_complete'``, Lark will be able\nparse just about anything as long as there is a valid way to generate it from\nthe Grammar, including looking 'into' the Regexes.\n\nThis examples shows how to parse a json input where the quotes have been\nreplaced by underscores: ``{_foo_:{}, _bar_: [], _baz_: __}``\nNotice that underscores might still appear inside strings, so a potentially\nvalid reading of the above is:\n``{\"foo_:{}, _bar\": [], \"baz\": \"\"}``\n"\
      ]\
    },\
    {\
      "cell_type": "code",\
      "execution_count": null,\
      "metadata": {\
        "collapsed": false\
      },\
      "outputs": [],\
      "source": [\
        "from pprint import pprint\n\nfrom lark import Lark, Tree, Transformer, v_args\nfrom lark.visitors import Transformer_InPlace\n\nGRAMMAR = r\"\"\"\n%import common.SIGNED_NUMBER\n%import common.WS_INLINE\n%import common.NEWLINE\n%ignore WS_INLINE\n\n?start: value\n\n?value: object\n      | array\n      | string\n      | SIGNED_NUMBER      -> number\n      | \"true\"             -> true\n      | \"false\"            -> false\n      | \"null\"             -> null\n\narray  : \"[\" (value (\",\" value)*)? \"]\"\nobject : \"{\" (pair (\",\" pair)*)? \"}\"\npair   : string \":\" value\n\nstring: STRING\nSTRING : ESCAPED_STRING\n\nESCAPED_STRING: QUOTE_CHAR _STRING_ESC_INNER QUOTE_CHAR\nQUOTE_CHAR: \"_\"\n\n_STRING_INNER: /.*/\n_STRING_ESC_INNER: _STRING_INNER /(?<!\\\\)(\\\\\\\\)*?/\n\n\"\"\"\n\n\ndef score(tree: Tree):\n    \"\"\"\n    Scores an option by how many children (and grand-children, and\n    grand-grand-children, ...) it has.\n    This means that the option with fewer large terminals gets selected\n\n    Between\n        object\n          pair\n            string\t_foo_\n            object\n          pair\n            string\t_bar_: [], _baz_\n            string\t__\n\n    and\n\n        object\n          pair\n            string\t_foo_\n            object\n          pair\n            string\t_bar_\n            array\n          pair\n            string\t_baz_\n            string\t__\n\n    this will give the second a higher score. (9 vs 13)\n    \"\"\"\n    return sum(len(t.children) for t in tree.iter_subtrees())\n\n\nclass RemoveAmbiguities(Transformer_InPlace):\n    \"\"\"\n    Selects an option to resolve an ambiguity using the score function above.\n    Scores each option and selects the one with the higher score, e.g. the one\n    with more nodes.\n\n    If there is a performance problem with the Tree having to many _ambig and\n    being slow and to large, this can instead be written as a ForestVisitor.\n    Look at the 'Custom SPPF Prioritizer' example.\n    \"\"\"\n    def _ambig(self, options):\n        return max(options, key=score)\n\n\nclass TreeToJson(Transformer):\n    \"\"\"\n    This is the same Transformer as the json_parser example.\n    \"\"\"\n    @v_args(inline=True)\n    def string(self, s):\n        return s[1:-1].replace('\\\\\"', '\"')\n\n    array = list\n    pair = tuple\n    object = dict\n    number = v_args(inline=True)(float)\n\n    null = lambda self, _: None\n    true = lambda self, _: True\n    false = lambda self, _: False\n\n\nparser = Lark(GRAMMAR, parser='earley', ambiguity=\"explicit\", lexer='dynamic_complete')\n\nEXAMPLES = [\n    r'{_array_:[1,2,3]}',\n\n    r'{_abc_: _array must be of the following format [_1_, _2_, _3_]_}',\n\n    r'{_foo_:{}, _bar_: [], _baz_: __}',\n\n    r'{_error_:_invalid_client_, _error_description_:_AADSTS7000215: Invalid '\n    r'client secret is provided.\\r\\nTrace ID: '\n    r'a0a0aaaa-a0a0-0a00-000a-00a00aaa0a00\\r\\nCorrelation ID: '\n    r'aa0aaa00-0aaa-0000-00a0-00000aaaa0aa\\r\\nTimestamp: 1997-10-10 00:00:00Z_, '\n    r'_error_codes_:[7000215], _timestamp_:_1997-10-10 00:00:00Z_, '\n    r'_trace_id_:_a0a0aaaa-a0a0-0a00-000a-00a00aaa0a00_, '\n    r'_correlation_id_:_aa0aaa00-0aaa-0000-00a0-00000aaaa0aa_, '\n    r'_error_uri_:_https://example.com_}',\n\n]\nfor example in EXAMPLES:\n    tree = parser.parse(example)\n    tree = RemoveAmbiguities().transform(tree)\n    result = TreeToJson().transform(tree)\n    pprint(result)"\
      ]\
    }\
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.7.17"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
```